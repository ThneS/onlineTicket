#!/usr/bin/env bash
set -euo pipefail

# Sync compiled ABIs from onlineTicket/out to frontend and backend abis folders.
# Requirements: forge build must have been run (produces ./out/*/*.json)
# Usage:
#   ./scripts/sync-abis.sh                 # default paths
#   FRONTEND_DIR=../TicketFrontend BACKEND_DIR=../backend ./scripts/sync-abis.sh

ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)
OUT_DIR="$ROOT_DIR/out"
FRONTEND_DIR_DEFAULT="$ROOT_DIR/../TicketFrontend/src/abis"
BACKEND_DIR_DEFAULT="$ROOT_DIR/../backend/src/contract/abis"

FRONTEND_ABIS_DIR="${FRONTEND_DIR:-$FRONTEND_DIR_DEFAULT}"
BACKEND_ABIS_DIR="${BACKEND_DIR:-$BACKEND_DIR_DEFAULT}"

mkdir -p "$FRONTEND_ABIS_DIR" "$BACKEND_ABIS_DIR"

if [ ! -d "$OUT_DIR" ]; then
  echo "[sync-abis] Build artifacts not found at $OUT_DIR. Running forge build..."
  (cd "$ROOT_DIR" && forge build >/dev/null)
fi

# Map contract names we care about
CONTRACTS=(
  PlatformToken
  TicketManager
  EventManager
  TokenSwap
  Marketplace
  ShowManager
  DIDRegistry
)

copy_abi() {
  local name="$1";
  local artifact="$OUT_DIR/${name}.sol/${name}.json"
  if [ ! -f "$artifact" ]; then
    echo "[warn] Artifact missing for $name at $artifact; skipping"
    return
  fi
  # Extract only the abi array to keep files lean
  local tmp=$(mktemp)
  jq '.abi' "$artifact" > "$tmp"
  cp "$tmp" "$FRONTEND_ABIS_DIR/${name}.json"
  cp "$tmp" "$BACKEND_ABIS_DIR/${name}.json"
  rm -f "$tmp"
  echo "[ok] ${name}.json updated in frontend and backend"
}

# Ensure jq exists
if ! command -v jq >/dev/null 2>&1; then
  echo "[error] jq is required. Install with: brew install jq"
  exit 1
fi

for c in "${CONTRACTS[@]}"; do
  copy_abi "$c"
done

# Generate/update frontend index.ts for convenient imports if present
INDEX_TS="$FRONTEND_ABIS_DIR/index.ts"
if [ -f "$INDEX_TS" ]; then
  # Try to keep existing file if it already accounts for new contracts; otherwise, patch minimal additions
  # We'll regenerate with a simple template including all contracts.
  cat > "$INDEX_TS" << 'EOF'
// Central export for all contract ABIs and address helpers
// Auto-generated by scripts/sync-abis.sh

import eventManager from './EventManager.json';
import ticketManager from './TicketManager.json';
import marketplace from './Marketplace.json';
import platformToken from './PlatformToken.json';
import tokenSwap from './TokenSwap.json';
import showManager from './ShowManager.json';
import didRegistry from './DIDRegistry.json';

export const ABIS = {
  eventManager: eventManager as const,
  ticketManager: ticketManager as const,
  marketplace: marketplace as const,
  platformToken: platformToken as const,
  tokenSwap: tokenSwap as const,
  showManager: showManager as const,
  didRegistry: didRegistry as const,
};

export const CONTRACT_ADDRESSES = {
  eventManager: import.meta.env.VITE_EVENT_MANAGER as `0x${string}` | undefined,
  ticketManager: import.meta.env.VITE_TICKET_MANAGER as `0x${string}` | undefined,
  marketplace: import.meta.env.VITE_MARKETPLACE as `0x${string}` | undefined,
  platformToken: import.meta.env.VITE_PLATFORM_TOKEN as `0x${string}` | undefined,
  tokenSwap: import.meta.env.VITE_TOKEN_SWAP as `0x${string}` | undefined,
  showManager: import.meta.env.VITE_SHOW_MANAGER as `0x${string}` | undefined,
  didRegistry: import.meta.env.VITE_DID_REGISTRY as `0x${string}` | undefined,
} as const;

export function getAddress(key: keyof typeof CONTRACT_ADDRESSES, chainId?: number): `0x${string}` | undefined {
  try {
    const mappingRaw = import.meta.env.VITE_CONTRACTS_JSON;
    if (chainId && mappingRaw) {
      const parsed = JSON.parse(mappingRaw);
      const networkConfig = parsed[String(chainId)];
      if (networkConfig) {
        const upper = key.toUpperCase();
        return networkConfig[upper] || networkConfig[key] || CONTRACT_ADDRESSES[key];
      }
    }
    return CONTRACT_ADDRESSES[key];
  } catch (e) {
    console.warn('Failed parsing VITE_CONTRACTS_JSON', e);
    return CONTRACT_ADDRESSES[key];
  }
}
EOF
  echo "[ok] frontend index.ts regenerated"
fi

echo "[done] ABI sync complete"
